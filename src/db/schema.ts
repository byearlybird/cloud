/**
 * Database Schemas - Single Source of Truth
 *
 * This file contains Drizzle ORM table definitions and auto-generated Zod schemas.
 *
 * Usage:
 * - Tables (users, documents, refreshTokens): Import for database queries
 * - Schemas (userSchema, documentSchema, etc.): Import for validation
 * - Types (User, Document, etc.): Import for type-safe operations
 *
 * The schemas are generated by drizzle-zod and can be extended/modified using
 * .extend(), .omit(), .pick() for API-specific validation needs.
 *
 * Note: Some services may extend these schemas for API input validation
 * (e.g., using 'password' instead of 'hashedPassword' for sign-up endpoints).
 */

import type { AnyObject, JsonDocument } from "@byearlybird/starling";
import * as t from "drizzle-orm/sqlite-core";
import { sqliteTable } from "drizzle-orm/sqlite-core";
import { createInsertSchema, createSelectSchema } from "drizzle-zod";
import type z from "zod";

const timestamps = {
	createdAt: t
		.text()
		.notNull()
		.$defaultFn(() => new Date().toISOString()),
	updatedAt: t
		.text()
		.notNull()
		.$defaultFn(() => new Date().toISOString())
		.$onUpdateFn(() => new Date().toISOString()),
};

export const users = sqliteTable("users", (t) => ({
	id: t
		.text()
		.primaryKey()
		.$defaultFn(() => crypto.randomUUID()), // UUID v4
	email: t.text().notNull().unique(),
	hashedPassword: t.text().notNull(),
	encryptedMasterKey: t.text().notNull(),
	...timestamps,
}));

/**
 * Refresh tokens table - stores all refresh tokens
 * Tokens are marked as revoked when user logs out or during token rotation
 */
export const refreshTokens = sqliteTable(
	"refresh_tokens",
	(t) => ({
		id: t
			.text()
			.primaryKey()
			.$defaultFn(() => crypto.randomUUID()),
		userId: t
			.text()
			.notNull()
			.references(() => users.id, { onDelete: "cascade" }),
		tokenHash: t.text().notNull(), // Bun.hash() of JWT
		revokedAt: t.text(), // ISO 8601 datetime - null = active, set = revoked
		lastUsedAt: t
			.text()
			.notNull()
			.$defaultFn(() => new Date().toISOString()), // ISO 8601 datetime
		...timestamps,
	}),
	(table) => [
		t
			.uniqueIndex("idx_refresh_tokens_user_hash")
			.on(table.userId, table.tokenHash),
		t.index("idx_refresh_tokens_user_id").on(table.userId),
		t.index("idx_refresh_tokens_revoked_at").on(table.revokedAt),
	],
);

/**
 * Documents table - stores user documents in JSON:API format
 * The documentData column contains the full JsonDocument<AnyObject> structure
 */
export const documents = sqliteTable(
	"documents",
	(t) => ({
		id: t
			.text()
			.primaryKey()
			.$defaultFn(() => crypto.randomUUID()),
		userId: t
			.text()
			.notNull()
			.references(() => users.id, { onDelete: "cascade" }),
		documentKey: t.text().notNull(), // e.g., "settings", "notes"
		documentData: t
			.text({ mode: "json" })
			.$type<JsonDocument<AnyObject>>()
			.notNull(),
		...timestamps,
	}),
	(table) => [
		t.uniqueIndex("idx_documents_user_key").on(table.userId, table.documentKey),
	],
);

export const userSchema = createSelectSchema(users);
export const newUserSchema = createInsertSchema(users);
export type User = z.infer<typeof userSchema>;
export type NewUser = z.infer<typeof newUserSchema>;

export const refreshTokenSchema = createSelectSchema(refreshTokens);
export const newRefreshTokenSchema = createInsertSchema(refreshTokens);
export type RefreshToken = z.infer<typeof refreshTokenSchema>;
export type NewRefreshToken = z.infer<typeof newRefreshTokenSchema>;

export const documentSchema = createSelectSchema(documents);
export const newDocumentSchema = createInsertSchema(documents);
export type Document = z.infer<typeof documentSchema>;
export type NewDocument = z.infer<typeof newDocumentSchema>;
